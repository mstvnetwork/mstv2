<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Broadcast Sync Player</title>
<style>
  #muteBtn {
    position: fixed;
    top: 10px;
    right: 10px;
    cursor: pointer;
    font-size: 24px;
    user-select: none;
  }
  video {
    width: 100%;
    max-width: 720px;
    height: auto;
    background: black;
  }
</style>
</head>
<body>

<video id="player" controls muted></video>
<div id="muteBtn" title="Toggle Mute">ðŸ”‡</div>

<script>
  // 1. Fetch data from JSON folder
  async function fetchSchedule() {
    try {
      const response = await fetch('./json/data.json'); // your json folder path
      if (!response.ok) throw new Error('Failed to load JSON');
      const data = await response.json();
      return data;
    } catch (err) {
      console.error(err);
      return null;
    }
  }

  // 4. Decode encrypted URL (example: base64 decode)
  function decodeUrl(encodedUrl) {
    // This example assumes URLs are base64 encoded
    try {
      return atob(encodedUrl);
    } catch (e) {
      console.warn('URL decode failed:', e);
      return encodedUrl; // fallback
    }
  }

  // 2. Real broadcast time sync calculator
  // This example assumes JSON data has an array of schedule items with:
  // { "start": "HH:mm:ss", "end": "HH:mm:ss", "url": "encodedUrl" }
  function getCurrentStreamUrl(schedule) {
    const now = new Date();
    // Convert current time to seconds since midnight
    const secondsNow = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();

    for (const item of schedule) {
      // parse start/end times "HH:mm:ss" into seconds since midnight
      const [sh, sm, ss] = item.start.split(':').map(Number);
      const [eh, em, es] = item.end.split(':').map(Number);
      const startSeconds = sh * 3600 + sm * 60 + ss;
      const endSeconds = eh * 3600 + em * 60 + es;

      if (secondsNow >= startSeconds && secondsNow < endSeconds) {
        return decodeUrl(item.url);
      }
    }
    return null; // no current stream
  }

  // 3. Unmute/mute logic with localStorage
  const video = document.getElementById('player');
  const muteBtn = document.getElementById('muteBtn');

  function updateMuteIcon() {
    muteBtn.textContent = video.muted ? 'ðŸ”‡' : 'ðŸ”Š';
  }

  muteBtn.addEventListener('click', () => {
    video.muted = !video.muted;
    localStorage.setItem('videoMuted', video.muted);
    updateMuteIcon();
  });

  // Initialize mute state from localStorage
  function initMuteState() {
    const mutedStored = localStorage.getItem('videoMuted');
    if (mutedStored !== null) {
      video.muted = (mutedStored === 'true');
    }
    updateMuteIcon();
  }

  async function initPlayer() {
    initMuteState();

    const scheduleData = await fetchSchedule();
    if (!scheduleData || !Array.isArray(scheduleData.schedule)) {
      console.error('Invalid or missing schedule data');
      return;
    }

    function updateStream() {
      const url = getCurrentStreamUrl(scheduleData.schedule);
      if (url && video.src !== url) {
        video.src = url;
        video.play().catch(() => {
          /* autoplay might be blocked without user interaction */
        });
      }
      else if (!url) {
        video.pause();
        video.removeAttribute('src');
        video.load();
      }
    }

    updateStream();

    // Update every 10 seconds to resync
    setInterval(updateStream, 10000);
  }

  initPlayer();
</script>

</body>
</html>
