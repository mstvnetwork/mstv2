<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV Broadcast</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: sans-serif;
            color: white;
        }
        .video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the video fits within the container */
            display: block;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s ease-in-out;
            pointer-events: all; /* Make sure it's clickable (for errors/messages) */
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }
        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid gold; /* Golden yellow spinner */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            margin-top: 20px;
            font-size: 1.2em;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* --- NEW/UPDATED CSS FOR SPEAKER ICON --- */
        #speakerIcon { /* Changed from .mute-button to #speakerIcon */
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 11; /* Above video, below loading overlay */
            font-size: 36px; /* Controls emoji size directly */
            color: white; /* May not affect all emojis, but good practice */
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 60px; /* Explicit width/height for the circular background */
            height: 60px;
            display: flex; /* Use flexbox to center the emoji */
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none; /* Prevent text selection */
            transition: background 0.3s ease;
        }
        #speakerIcon:hover {
            background: rgba(0,0,0,0.7);
        }
        /* --- END NEW/UPDATED CSS --- */

    </style>
</head>
<body>
    <div class="video-container">
        <video id="videoPlayer" playsinline autoplay muted></video>

        <div id="speakerIcon">ðŸ”‡</div>
        <div id="loadingOverlay" class="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-text">Loading broadcast...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const speakerIcon = document.getElementById('speakerIcon'); // Renamed from muteToggle
        // const muteIcon = document.getElementById('muteIcon'); // No longer needed
        let hls;
        let isMuted = true; // Initial state: video starts muted by default
        let currentSegmentIndex = 0;
        let segmentPlayTimeout;

        // Function to get query parameters
        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        // Fetch video data
        async function fetchVideoData() {
            try {
                const response = await fetch('/videos.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Could not fetch video data:", error);
                return null;
            }
        }

        function parseDateTimeInTimeZone(dateTimeString, timeZone) {
            try {
                const dateStringWithOffset = `${dateTimeString}+10:00`;
                const dateInAEST = new Date(dateStringWithOffset);
                if (isNaN(dateInAEST.getTime())) {
                    throw new Error("Invalid date string or timezone parsing.");
                }
                return dateInAEST.getTime();
            } catch (e) {
                console.error(`Error parsing date-time string "${dateTimeString}" in timezone "${timeZone}":`, e);
                return null;
            }
        }

        function getCurrentSegmentAndSeekTime(broadcastStartTimeMs, segments) {
            const currentTimeMs = Date.now();
            const totalElapsedTimeSeconds = (currentTimeMs - broadcastStartTimeMs) / 1000;

            if (segments.length === 0) {
                return null;
            }

            let accumulatedDuration = 0;
            let currentSegment = null;
            let currentSegmentIdx = -1;
            let seekTimeInSegment = 0;

            const totalSegmentsDuration = segments.reduce((sum, s) => sum + s.durationSeconds, 0);

            const effectiveTimeInCycle = totalSegmentsDuration > 0 ?
                totalElapsedTimeSeconds % totalSegmentsDuration :
                0;

            const normalizedEffectiveTime = effectiveTimeInCycle < 0 ?
                                           effectiveTimeInCycle + totalSegmentsDuration :
                                           effectiveTimeInCycle;

            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (normalizedEffectiveTime >= accumulatedDuration &&
                    normalizedEffectiveTime < accumulatedDuration + segment.durationSeconds) {

                    currentSegment = segment;
                    currentSegmentIdx = i;
                    seekTimeInSegment = normalizedEffectiveTime - accumulatedDuration;
                    break;
                }
                accumulatedDuration += segment.durationSeconds;
            }

            if (!currentSegment && segments.length > 0) {
                currentSegment = segments[0];
                currentSegmentIdx = 0;
                seekTimeInSegment = 0;
            }

            return {
                segment: currentSegment,
                seekTime: seekTimeInSegment,
                segmentIndex: currentSegmentIdx
            };
        }

        // Centralized function to try to play the video
        function attemptVideoPlay() {
            // Set the video muted state based on our persistent `isMuted` variable
            videoPlayer.muted = isMuted;
            // Removed updateMuteIcon() call here as it's handled by speakerIcon.textContent directly

            videoPlayer.play().then(() => {
                // If playback successfully starts (even if muted)
                console.log(`Video playing successfully. Current time: ${videoPlayer.currentTime.toFixed(2)}s`);
                loadingOverlay.classList.add('hidden'); // Hide loading spinner
            }).catch(error => {
                // This catch should ideally only trigger in very rare, strict cases
                console.error("Video play failed (autoplay blocked even when muted, user interaction might be forced):", error);
                loadingOverlay.innerHTML = `<div class='loading-text'>Autoplay blocked. Please refresh or click the speaker icon to start. Error: ${error.message}</div>`;
                // Keep the loading overlay visible with the error message
            });
        }

        function playSegment(url, seekTime, segmentDuration, currentSegmentIdx, allSegments) {
            if (hls) {
                hls.destroy(); // Destroy previous HLS instance
            }
            clearTimeout(segmentPlayTimeout); // Clear any existing timeout

            // Always show loading spinner when a new segment is being loaded
            loadingOverlay.classList.remove('hidden');
            loadingOverlay.innerHTML = "<div class='spinner'></div><div class='loading-text'>Loading broadcast...</div>"; // Reset text/spinner

            // Reset playback setup flag
            videoPlayer.dataset.playbackSetupDone = '';

            console.log(`Preparing segment ${currentSegmentIdx + 1}: ${url}`);

            const setupPlayback = () => {
                // This flag prevents this function from running multiple times for a single load
                if (videoPlayer.dataset.playbackSetupDone) return;
                videoPlayer.dataset.playbackSetupDone = 'true';

                if (isNaN(videoPlayer.duration) || videoPlayer.duration <= 0) {
                    console.warn(`Video duration not yet available or invalid for ${url}.`);
                }

                videoPlayer.currentTime = seekTime;
                console.log(`HLS: Segment loaded. Attempting play from ${seekTime.toFixed(2)}s. Declared video duration: ${videoPlayer.duration.toFixed(2)}s`);

                attemptVideoPlay(); // Attempt to play the video (will be muted initially)

                // Set up timeout for next segment, AFTER attempting to play
                const remainingPlayTime = segmentDuration - videoPlayer.currentTime;
                if (remainingPlayTime > 0) {
                     segmentPlayTimeout = setTimeout(() => {
                         console.log("Segment duration reached, moving to next segment.");
                         playNextSegment(currentSegmentIdx, allSegments);
                     }, remainingPlayTime * 1000);
                     console.log(`Scheduled next segment in ${remainingPlayTime.toFixed(2)} seconds.`);
                } else {
                    console.warn("Segment's effective play time is zero or negative, moving to next segment immediately.");
                    playNextSegment(currentSegmentIdx, allSegments);
                }
            };

            if (Hls.isSupported()) {
                hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(videoPlayer);

                hls.on(Hls.Events.MANIFEST_PARSED, setupPlayback);
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error("HLS.js error:", data);
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error("Fatal MEDIA_ERROR encountered, trying to recover.");
                                hls.recoverMediaError();
                                break;
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error("Fatal NETWORK_ERROR encountered, might need user refresh.");
                                break;
                            default:
                                console.error("Unrecoverable HLS error. Stopping playback.");
                                if (hls) hls.destroy();
                                loadingOverlay.innerHTML = "<div class='loading-text'>Video playback error. Please try again.</div>";
                                break;
                        }
                    }
                    // Keep error message on screen
                });
                videoPlayer.onloadedmetadata = () => {
                    if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 1) { // ENOUGH_DATA
                         console.log("Video metadata loaded (non-HLS or early event).");
                         setupPlayback();
                    }
                };
                videoPlayer.oncanplay = () => {
                    if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 3) { // ENOUGH_DATA for smooth play
                        console.log("Video can play (oncanplay event).");
                        setupPlayback();
                    }
                };


            } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                // For native HLS support (Safari)
                videoPlayer.src = url;
                videoPlayer.addEventListener('loadedmetadata', function listener() {
                    this.removeEventListener('loadedmetadata', listener);
                    setupPlayback();
                });
                videoPlayer.onerror = () => {
                    console.error("Native HLS video error.");
                    // Keep error message on screen
                };
            } else {
                console.error("HLS is not supported in this browser.");
                loadingOverlay.innerHTML = "<div class='loading-text'>Your browser does not support HLS video streaming.</div>";
                alert("Your browser does not support HLS video streaming.");
            }
        }

        function playNextSegment(currentIdx, segments) {
            if (!window.selectedChannelData) {
                console.error("No channel data available for next segment playback.");
                return;
            }

            const currentBroadcastData = getCurrentSegmentAndSeekTime(
                window.selectedChannelData.broadcastStartTimeMs,
                window.selectedChannelData.segments
            );

            if (currentBroadcastData && currentBroadcastData.segment) {
                currentSegmentIndex = currentBroadcastData.segmentIndex;
                playSegment(
                    currentBroadcastData.segment.url,
                    currentBroadcastData.seekTime,
                    currentBroadcastData.segment.durationSeconds,
                    currentBroadcastData.segmentIndex,
                    window.selectedChannelData.segments
                );
            } else {
                 console.error("Could not determine next segment to play after timeout.");
                 // Fallback: try to play the first segment from start if something went wrong
                 currentSegmentIndex = 0;
                 playSegment(
                    segments[0].url,
                    0,
                    segments[0].durationSeconds,
                    0,
                    window.selectedChannelData.segments
                 );
            }
        }

        // --- UPDATED MUTE TOGGLE FUNCTION ---
        function toggleMute() {
            isMuted = !isMuted; // Toggle the persistent state
            videoPlayer.muted = isMuted; // Apply the state to the video element
            speakerIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ'; // Update emoji
            
            // If the video is paused (e.g., still blocked from previous attempt),
            // this user interaction might enable playback.
            if (!videoPlayer.paused) { // Check if it's not currently paused by user
                 videoPlayer.play().catch(e => console.log("Attempted play after mute toggle, but failed:", e));
            }
        }
        // --- END UPDATED MUTE TOGGLE FUNCTION ---

        // Removed updateMuteIcon() function as it's no longer needed

        window.selectedChannelData = null; // Global to store selected channel details

        document.addEventListener('DOMContentLoaded', async () => {
            const channel = getQueryParam('ch');

            if (!channel) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Please specify a channel (e.g., ?ch=1)</div>";
                return;
            }

            const videoData = await fetchVideoData();
            if (!videoData) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Error loading video data.</div>";
                return;
            }

            const selectedChannel = videoData.find(v => v.channel === parseInt(channel));

            if (selectedChannel) {
                const broadcastStartTimeMs = parseDateTimeInTimeZone(selectedChannel.startDateTimeAEST, 'Australia/Melbourne');

                if (broadcastStartTimeMs === null) {
                    loadingOverlay.innerHTML = "<div class='loading-text'>Error: Invalid start time for channel.</div>";
                    return;
                }

                window.selectedChannelData = {
                    broadcastStartTimeMs: broadcastStartTimeMs,
                    segments: selectedChannel.segments
                };

                const initialBroadcastState = getCurrentSegmentAndSeekTime(broadcastStartTimeMs, selectedChannel.segments);

                if (initialBroadcastState && initialBroadcastState.segment) {
                    currentSegmentIndex = initialBroadcastState.segmentIndex;
                    playSegment(
                        initialBroadcastState.segment.url,
                        initialBroadcastState.seekTime,
                        initialBroadcastState.segment.durationSeconds,
                        initialBroadcastState.segmentIndex,
                        selectedChannel.segments
                    );
                } else {
                    console.error("No segments found for this channel or initial state could not be determined.");
                    loadingOverlay.innerHTML = "<div class='loading-text'>Channel has no video segments.</div>";
                }

            } else {
                console.error(`Channel ${channel} not found.`);
                loadingOverlay.innerHTML = `<div class='loading-text'>Channel ${channel} not found.</div>`;
            }

            speakerIcon.addEventListener('click', toggleMute); // Attach event listener to new speakerIcon element

            videoPlayer.controls = false;
        });
    </script>
</body>
</html>
