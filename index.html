<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV Broadcast</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: sans-serif;
            color: white;
        }
        .video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* --- UPDATED PLAYER STYLES --- */
        video, iframe { /* Apply common sizing to both players */
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures video fits, iframe often handles its own scaling */
            display: block; /* Ensures they take up space */
            position: absolute; /* Stack them on top of each other */
            top: 0;
            left: 0;
        }
        .player-hidden { /* New class to hide players */
            display: none !important;
        }
        /* --- END UPDATED PLAYER STYLES --- */

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s ease-in-out;
            pointer-events: all;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid gold;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            margin-top: 20px;
            font-size: 1.2em;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #speakerIcon {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 11;
            font-size: 36px;
            color: white;
            background: rgba(0,0,0,0.5);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s ease;
        }
        #speakerIcon:hover {
            background: rgba(0,0,0,0.7);
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="videoPlayer" playsinline autoplay muted class="player-hidden"></video> 
        
        <iframe id="iframePlayer" class="player-hidden" frameborder="0" allowfullscreen allow="autoplay; encrypted-media; gyroscope; picture-in-picture"></iframe>

        <div id="speakerIcon">ðŸ”‡</div>
        <div id="loadingOverlay" class="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-text">Loading broadcast...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const iframePlayer = document.getElementById('iframePlayer'); // New reference
        const loadingOverlay = document.getElementById('loadingOverlay');
        const speakerIcon = document.getElementById('speakerIcon');
        let hls;
        let isMuted = true;
        let currentSegmentIndex = 0;
        let segmentPlayTimeout;
        let activePlayerType = null; // To track which player is active ('hls' or 'iframe')

        // Utility functions (getQueryParam, fetchVideoData, parseDateTimeInTimeZone, getCurrentSegmentAndSeekTime)
        // ... (These remain unchanged from your previous version)
        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        async function fetchVideoData() {
            try {
                const response = await fetch('/videos.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Could not fetch video data:", error);
                return null;
            }
        }

        function parseDateTimeInTimeZone(dateTimeString, timeZone) {
            try {
                const dateStringWithOffset = `${dateTimeString}+10:00`;
                const dateInAEST = new Date(dateStringWithOffset);
                if (isNaN(dateInAEST.getTime())) {
                    throw new Error("Invalid date string or timezone parsing.");
                }
                return dateInAEST.getTime();
            } catch (e) {
                console.error(`Error parsing date-time string "${dateTimeString}" in timezone "${timeZone}":`, e);
                return null;
            }
        }

        function getCurrentSegmentAndSeekTime(broadcastStartTimeMs, segments) {
            const currentTimeMs = Date.now();
            const totalElapsedTimeSeconds = (currentTimeMs - broadcastStartTimeMs) / 1000;

            if (segments.length === 0) {
                return null;
            }

            let accumulatedDuration = 0;
            let currentSegment = null;
            let currentSegmentIdx = -1;
            let seekTimeInSegment = 0;

            const totalSegmentsDuration = segments.reduce((sum, s) => sum + s.durationSeconds, 0);

            const effectiveTimeInCycle = totalSegmentsDuration > 0 ?
                totalElapsedTimeSeconds % totalSegmentsDuration :
                0;

            const normalizedEffectiveTime = effectiveTimeInCycle < 0 ?
                                           effectiveTimeInCycle + totalSegmentsDuration :
                                           effectiveTimeInCycle;

            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (normalizedEffectiveTime >= accumulatedDuration &&
                    normalizedEffectiveTime < accumulatedDuration + segment.durationSeconds) {

                    currentSegment = segment;
                    currentSegmentIdx = i;
                    seekTimeInSegment = normalizedEffectiveTime - accumulatedDuration;
                    break;
                }
                accumulatedDuration += segment.durationSeconds;
            }

            if (!currentSegment && segments.length > 0) {
                currentSegment = segments[0];
                currentSegmentIdx = 0;
                seekTimeInSegment = 0;
            }

            return {
                segment: currentSegment,
                seekTime: seekTimeInSegment,
                segmentIndex: currentSegmentIdx
            };
        }


        // --- NEW: Function to manage player visibility ---
        function showPlayer(type) {
            if (type === 'hls') {
                videoPlayer.classList.remove('player-hidden');
                iframePlayer.classList.add('player-hidden');
                activePlayerType = 'hls';
            } else if (type === 'iframe') {
                iframePlayer.classList.remove('player-hidden');
                videoPlayer.classList.add('player-hidden');
                activePlayerType = 'iframe';
            }
            // Mute icon is always visible, but its functionality will differ for iframe
            speakerIcon.classList.remove('player-hidden'); 
        }

        // --- MODIFIED: playSegment to handle HLS or iframe ---
        function playSegment(segmentData, allSegments) {
            clearTimeout(segmentPlayTimeout); // Clear any existing timeout

            // Always show loading spinner when a new segment is being loaded
            loadingOverlay.classList.remove('hidden');
            loadingOverlay.innerHTML = "<div class='spinner'></div><div class='loading-text'>Loading broadcast...</div>"; // Reset text/spinner

            // Reset playback setup flag for HLS player
            videoPlayer.dataset.playbackSetupDone = '';

            const url = segmentData.url;
            const seekTime = segmentData.seekTime; // Only relevant for HLS
            const segmentDuration = segmentData.durationSeconds;
            const currentSegmentIdx = segmentData.segmentIndex;
            const type = segmentData.type || 'hls'; // Default to 'hls' if not specified

            console.log(`Preparing segment ${currentSegmentIdx + 1} (Type: ${type}): ${url}`);

            if (type === 'hls') {
                showPlayer('hls');
                // Ensure iframe is paused/stopped if we switch back
                iframePlayer.src = ''; 

                if (hls) {
                    hls.destroy();
                }

                videoPlayer.muted = isMuted; // Apply mute state
                speakerIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ'; // Update emoji
                
                const setupHlsPlayback = () => {
                    if (videoPlayer.dataset.playbackSetupDone) return;
                    videoPlayer.dataset.playbackSetupDone = 'true';

                    if (isNaN(videoPlayer.duration) || videoPlayer.duration <= 0) {
                        console.warn(`Video duration not yet available or invalid for ${url}.`);
                    }

                    videoPlayer.currentTime = seekTime;
                    console.log(`HLS: Segment loaded. Attempting play from ${seekTime.toFixed(2)}s.`);

                    videoPlayer.play().then(() => {
                        console.log(`HLS Video playing successfully (muted: ${videoPlayer.muted}).`);
                        loadingOverlay.classList.add('hidden'); // Hide loading spinner

                        const remainingPlayTime = segmentDuration - videoPlayer.currentTime;
                        if (remainingPlayTime > 0) {
                            segmentPlayTimeout = setTimeout(() => {
                                console.log("HLS Segment duration reached, moving to next segment.");
                                playNextSegment(currentSegmentIdx, allSegments);
                            }, remainingPlayTime * 1000);
                            console.log(`Scheduled next HLS segment in ${remainingPlayTime.toFixed(2)} seconds.`);
                        } else {
                            console.warn("HLS Segment's effective play time is zero or negative, moving to next segment immediately.");
                            playNextSegment(currentSegmentIdx, allSegments);
                        }

                    }).catch(error => {
                        console.error("HLS Video play failed (autoplay blocked even when muted, user interaction might be forced):", error);
                        loadingOverlay.innerHTML = `<div class='loading-text'>Autoplay blocked. Please refresh or click the speaker icon to start. Error: ${error.message}</div>`;
                    });
                };

                if (Hls.isSupported()) {
                    hls = new Hls();
                    hls.loadSource(url);
                    hls.attachMedia(videoPlayer);

                    hls.on(Hls.Events.MANIFEST_PARSED, setupHlsPlayback);
                    hls.on(Hls.Events.ERROR, function(event, data) {
                        console.error("HLS.js error:", data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error("Fatal MEDIA_ERROR encountered, trying to recover.");
                                    hls.recoverMediaError();
                                    break;
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error("Fatal NETWORK_ERROR encountered, might need user refresh.");
                                    break;
                                default:
                                    console.error("Unrecoverable HLS error. Stopping playback.");
                                    if (hls) hls.destroy();
                                    loadingOverlay.innerHTML = "<div class='loading-text'>HLS video playback error. Please try again.</div>";
                                    break;
                            }
                        }
                    });
                    videoPlayer.onloadedmetadata = () => {
                        if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 1) {
                            setupHlsPlayback();
                        }
                    };
                    videoPlayer.oncanplay = () => {
                        if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 3) {
                            setupHlsPlayback();
                        }
                    };

                } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    videoPlayer.src = url;
                    videoPlayer.addEventListener('loadedmetadata', function listener() {
                        this.removeEventListener('loadedmetadata', listener);
                        setupHlsPlayback();
                    });
                    videoPlayer.onerror = () => {
                        console.error("Native HLS video error.");
                    };
                } else {
                    console.error("HLS is not supported in this browser.");
                    loadingOverlay.innerHTML = "<div class='loading-text'>Your browser does not support HLS video streaming.</div>";
                    alert("Your browser does not support HLS video streaming.");
                }

            } else if (type === 'iframe') {
                showPlayer('iframe');
                // Ensure HLS player is paused/stopped if we switch to iframe
                if (hls) {
                    hls.destroy();
                }
                videoPlayer.src = '';
                videoPlayer.pause();

                // Build the iframe URL, potentially adding autoplay/mute parameters
                let iframeSrc = url;
                // Example for YouTube: Append &autoplay=1&mute=1. Other services have different params.
                if (iframeSrc.includes('youtube.com/embed')) {
                    const separator = iframeSrc.includes('?') ? '&' : '?';
                    iframeSrc += `${separator}autoplay=1`;
                    if (isMuted) {
                        iframeSrc += `&mute=1`;
                    } else {
                        // If unmute is desired, some providers might require it to be set explicitly to 0
                        // iframeSrc += `&mute=0`;
                    }
                }
                // Add similar logic for other iframe providers like Vimeo if needed
                
                iframePlayer.src = iframeSrc;
                
                // For iframes, we can't detect "playing" easily. Assume it's loading.
                // We'll hide the overlay after a short delay or rely on user interaction.
                // It's challenging to precisely know when an iframe's video starts playing.
                // For simplicity, we'll hide the loading overlay after a brief delay.
                setTimeout(() => {
                    loadingOverlay.classList.add('hidden');
                    console.log(`Iframe loaded: ${iframeSrc}`);
                }, 1000); // Hide loading after 1 second for iframes

                // Schedule the next segment based on iframe's declared duration
                const remainingPlayTime = segmentDuration; // No seekTime for iframes
                if (remainingPlayTime > 0) {
                     segmentPlayTimeout = setTimeout(() => {
                         console.log("Iframe segment duration reached, moving to next segment.");
                         playNextSegment(currentSegmentIdx, allSegments);
                     }, remainingPlayTime * 1000);
                     console.log(`Scheduled next Iframe segment in ${remainingPlayTime.toFixed(2)} seconds.`);
                } else {
                    console.warn("Iframe segment has zero or negative duration, moving to next segment immediately.");
                    playNextSegment(currentSegmentIdx, allSegments);
                }

            } else {
                console.error(`Unknown segment type: ${type}`);
                loadingOverlay.innerHTML = `<div class='loading-text'>Error: Unknown video type for segment.</div>`;
            }
        }

        function playNextSegment(currentIdx, segments) {
            if (!window.selectedChannelData) {
                console.error("No channel data available for next segment playback.");
                return;
            }

            const currentBroadcastData = getCurrentSegmentAndSeekTime(
                window.selectedChannelData.broadcastStartTimeMs,
                window.selectedChannelData.segments
            );

            if (currentBroadcastData && currentBroadcastData.segment) {
                // Pass the full segment object (including type) and the calculated seekTime
                playSegment({
                    ...currentBroadcastData.segment, // Spread operator to include 'type' and other props
                    seekTime: currentBroadcastData.seekTime,
                    segmentIndex: currentBroadcastData.segmentIndex // Ensure index is passed for logging
                }, window.selectedChannelData.segments);
            } else {
                 console.error("Could not determine next segment to play after timeout.");
                 currentSegmentIndex = 0;
                 // Fallback to the first segment, ensure it has a type
                 const firstSegment = window.selectedChannelData.segments[0];
                 playSegment({
                    ...firstSegment,
                    seekTime: 0,
                    segmentIndex: 0
                 }, window.selectedChannelData.segments);
            }
        }

        function toggleMute() {
            if (activePlayerType === 'hls') {
                isMuted = !isMuted;
                videoPlayer.muted = isMuted;
                speakerIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ';
                if (!videoPlayer.paused) {
                    videoPlayer.play().catch(e => console.log("Attempted HLS play after mute toggle, but failed:", e));
                }
            } else if (activePlayerType === 'iframe') {
                // For iframes, we can't directly control mute/unmute unless the iframe API allows it.
                // We'll update our internal state, but the user might still need to click within the iframe.
                // This is a limitation of iframe sandboxing.
                isMuted = !isMuted;
                speakerIcon.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”ˆ';
                console.warn("Cannot directly control mute/unmute for iframe content. User might need to interact with iframe player controls.");
                // You might reload the iframe with new mute/autoplay params, but that restarts the video.
                // Example for YouTube:
                // if (iframePlayer.src.includes('youtube.com/embed')) {
                //     let currentSrc = iframePlayer.src.replace(/&mute=[01]/g, ''); // Remove existing mute param
                //     const separator = currentSrc.includes('?') ? '&' : '?';
                //     iframePlayer.src = currentSrc + `${separator}mute=${isMuted ? 1 : 0}`;
                // }
            }
        }

        window.selectedChannelData = null;

        document.addEventListener('DOMContentLoaded', async () => {
            const channel = getQueryParam('ch');

            if (!channel) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Please specify a channel (e.g., ?ch=1)</div>";
                return;
            }

            const videoData = await fetchVideoData();
            if (!videoData) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Error loading video data.</div>";
                return;
            }

            const selectedChannel = videoData.find(v => v.channel === parseInt(channel));

            if (selectedChannel) {
                const broadcastStartTimeMs = parseDateTimeInTimeZone(selectedChannel.startDateTimeAEST, 'Australia/Melbourne');

                if (broadcastStartTimeMs === null) {
                    loadingOverlay.innerHTML = "<div class='loading-text'>Error: Invalid start time for channel.</div>";
                    return;
                }

                window.selectedChannelData = {
                    broadcastStartTimeMs: broadcastStartTimeMs,
                    segments: selectedChannel.segments
                };

                const initialBroadcastState = getCurrentSegmentAndSeekTime(broadcastStartTimeMs, selectedChannel.segments);

                if (initialBroadcastState && initialBroadcastState.segment) {
                    currentSegmentIndex = initialBroadcastState.segmentIndex;
                    // Pass the full segment object and calculated seekTime to playSegment
                    playSegment({
                        ...initialBroadcastState.segment,
                        seekTime: initialBroadcastState.seekTime,
                        segmentIndex: initialBroadcastState.segmentIndex
                    }, selectedChannel.segments);
                } else {
                    console.error("No segments found for this channel or initial state could not be determined.");
                    loadingOverlay.innerHTML = "<div class='loading-text'>Channel has no video segments.</div>";
                }

            } else {
                console.error(`Channel ${channel} not found.`);
                loadingOverlay.innerHTML = `<div class='loading-text'>Channel ${channel} not found.</div>`;
            }

            speakerIcon.addEventListener('click', toggleMute);

            videoPlayer.controls = false; // Always ensure our HLS player doesn't show default controls
        });
    </script>
</body>
</html>
