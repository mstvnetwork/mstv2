<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSTV Net - Live Channels</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/mstvnet/mstvnet.github.io/main/icon.png">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            background-color: #1a1a1a;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.7); /* Green glow effect */
            padding: 20px;
            width: 100%;
            max-width: 900px; /* Adjust as needed */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative; /* For viewer count positioning */
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            color: #0f0; /* Bright green for title */
            margin-bottom: 5px;
            font-size: 2.5em;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.7);
        }

        .tagline {
            color: #00ff00;
            font-style: italic;
            margin-bottom: 20px;
        }

        .viewer-count {
            position: absolute;
            top: 10px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            color: #0f0;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .viewer-count::before {
            content: 'â€¢';
            color: red;
            font-size: 1.5em;
            line-height: 1;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from {
                opacity: 0.5;
            }
            to {
                opacity: 1;
            }
        }

        .channel-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        label {
            font-size: 1.1em;
            color: #00ff00;
        }

        select {
            width: 100%;
            max-width: 300px;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #0f0;
            background-color: #333;
            color: #fff;
            font-size: 1em;
            cursor: pointer;
            -webkit-appearance: none; /* Remove default dropdown arrow for custom styling */
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2300ff00%22%20d%3D%22M287%2C197.962L146.2%2C57.162L5.4%2C197.962h281.6z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
        }

        select:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #000;
            border-radius: 8px;
            overflow: hidden; /* Ensure content stays within bounds */
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        video, iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            display: block; /* Ensure it starts as a block */
            background-color: #000; /* Black background for video player */
        }

        #placeholder-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('https://raw.githubusercontent.com/mstvnet/mstvnet.github.io/main/placeholder.png') no-repeat center center / contain;
            background-color: #000;
            display: block; /* Initially visible */
            z-index: 10; /* Above video/iframe */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0, 255, 0, 0.3);
            border-top: 5px solid #0f0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none; /* Initially hidden */
            z-index: 11;
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }

        #unmute-button {
            background-color: rgba(0, 0, 0, 0.7);
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 5px;
            display: none; /* Initially hidden */
        }

        #unmute-button:hover {
            background-color: rgba(0, 255, 0, 0.2);
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 5; /* Below loading, above video */
        }

        .logo-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 120px; /* Adjust logo size */
            height: auto;
            opacity: 0.7; /* Semi-transparent */
        }

        .live-stamp {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #e74c3c; /* Red color */
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            animation: live-pulse 1.5s infinite;
        }

        @keyframes live-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
            }
        }

        footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="viewer-count" id="viewer-count">LIVE: 0 VIEWERS</div>
            <h1>MSTV Net</h1>
            <p class="tagline">Your ultimate destination for free online channels.</p>
        </header>

        <div class="channel-selector">
            <label for="channel-select">Select Channel:</label>
            <select id="channel-select">
                <option value="">ðŸ‘‰ðŸ“ºðŸ“ºðŸ“º</option>
                </select>
        </div>

        <div class="video-container">
            <video id="video-player" controls autoplay muted style="display:none;"></video>
            <iframe id="media-player" allow="autoplay; fullscreen" style="display:none;"></iframe>
            
            <div id="placeholder-image"></div>
            <div id="loading"></div>

            <div class="controls">
                <button id="unmute-button">
                    <span id="speaker-icon">ðŸ”‡</span> Unmute
                </button>
            </div>

            <div class="overlay">
                <img src="https://raw.githubusercontent.com/mstvnet/mstvnet.github.io/main/logo.png" alt="MSTV Net Logo" class="logo-overlay">
                <span class="live-stamp">LIVE</span>
            </div>
        </div>
    </div>

    <footer>
        <p>Â© 2024 MSTV Net. All rights reserved.</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        const select = document.getElementById('channel-select');
        const videoPlayer = document.getElementById('video-player');
        const iframePlayer = document.getElementById('media-player'); // This will now be used for YouTube embeds too
        const placeholder = document.getElementById('placeholder-image');
        const loading = document.getElementById('loading');
        const unmuteButton = document.getElementById('unmute-button');
        const speakerIcon = document.getElementById('speaker-icon');
        const viewerCountElement = document.getElementById('viewer-count');

        let hlsInstance = null;
        let youtubePlayer = null; // New: Variable for the YouTube Player API object
        let channelsData = [];

        let currentPlayingChannel = null; // Stores the entire channel object being played
        let currentPlaylistIndex = 0; // Tracks the current media item within a channel's mixed playlist

        const githubJsonUrl = 'channels.json';
        const pollingInterval = 5000; // Interval for refreshing channel list from JSON

        let currentViewerCount = 0;
        const minViewers = 500;
        const maxViewers = 5000;
        const animationDuration = 2000;
        const updateInterval = 5000; // Interval for viewer count updates

        // --- Utility functions ---
        function showLoading(show) {
            loading.style.display = show ? 'block' : 'none';
        }

        function updateSpeakerIcon() {
            // Only show the button if the videoPlayer is active and muted
            if (videoPlayer.style.display === 'block') {
                if (videoPlayer.muted) {
                    speakerIcon.textContent = 'ðŸ”‡';
                    unmuteButton.style.display = 'flex';
                } else {
                    speakerIcon.textContent = 'ðŸ”Š';
                    unmuteButton.style.display = 'none';
                }
            } else if (iframePlayer.style.display === 'block' && youtubePlayer) {
                // For YouTube, check its mute status
                // YouTube API returns 1 for muted, 0 for unmuted.
                // Make sure player is ready before calling isMuted()
                if (youtubePlayer.getPlayerState() !== -1 && youtubePlayer.isMuted() == 1) { 
                    speakerIcon.textContent = 'ðŸ”‡';
                    unmuteButton.style.display = 'flex';
                } else {
                    speakerIcon.textContent = 'ðŸ”Š';
                    unmuteButton.style.display = 'none';
                }
            } else {
                unmuteButton.style.display = 'none'; // Hide button if no player active
            }
        }

        unmuteButton.addEventListener('click', () => {
            if (videoPlayer.style.display === 'block') {
                videoPlayer.muted = false;
                videoPlayer.play(); // Attempt to play after unmute
            } else if (iframePlayer.style.display === 'block' && youtubePlayer) {
                youtubePlayer.unMute();
            }
            updateSpeakerIcon();
        });

        // Event listeners for video player to update mute button state
        videoPlayer.addEventListener('volumechange', updateSpeakerIcon);
        videoPlayer.addEventListener('play', updateSpeakerIcon); 
        videoPlayer.addEventListener('pause', updateSpeakerIcon); 

        // --- YouTube Player API Initialization ---
        // This function MUST be globally accessible and named onYouTubeIframeAPIReady
        // It's called automatically by the YouTube API script when it loads.
        function onYouTubeIframeAPIReady() {
            console.log("YouTube Iframe API is ready.");
            // No need to create player here, it will be created when a YouTube video is selected.
        }

        function createYouTubePlayer(videoId, mute = true) {
            // Ensure iframePlayer is visible and videoPlayer is hidden before creating YouTube player
            videoPlayer.style.display = 'none';
            iframePlayer.style.display = 'block'; 

            if (youtubePlayer) {
                youtubePlayer.destroy(); // Destroy existing player if any
                youtubePlayer = null;
            }

            youtubePlayer = new YT.Player('media-player', { // 'media-player' is the ID of your iframe
                videoId: videoId,
                playerVars: {
                    'autoplay': 1,
                    'controls': 0,
                    'mute': mute ? 1 : 0, // Initial mute state
                    'enablejsapi': 1,
                    'modestbranding': 1,
                    'rel': 0, // Do not show related videos
                    'showinfo': 0, // Hide video title and uploader info
                    'iv_load_policy': 3 // Do not show video annotations
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            console.log("YouTube player ready.");
            // Attempt to play, but respect browser autoplay policies.
            event.target.playVideo().then(() => {
                showLoading(false);
                updateSpeakerIcon();
            }).catch(error => {
                console.warn("YouTube playVideo failed (likely autoplay blocked):", error);
                // If autoplay is blocked, player might still be muted.
                // Keep loading indicator if it's still buffering/not playing.
                // The 'unmute' button will be visible if muted.
                if (youtubePlayer && youtubePlayer.isMuted() == 1) {
                    updateSpeakerIcon(); // Make sure unmute button is visible
                } else {
                    showLoading(false); // If not muted, and not playing, something else is wrong.
                }
            });
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                console.log("YouTube video ended.");
                playNextInSequence();
            } else if (event.data === YT.PlayerState.PLAYING) {
                showLoading(false);
                updateSpeakerIcon(); // Update speaker icon if unmuted manually
            } else if (event.data === YT.PlayerState.BUFFERING) {
                showLoading(true);
            }
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            showLoading(false);
            placeholder.style.display = 'block';
            unmuteButton.style.display = 'none';
            // Attempt to play next video on error
            playNextInSequence();
        }


        // --- Core Playback Logic ---

        // Function to play the next item in the current sequential playlist
        function playNextInSequence() {
            if (!currentPlayingChannel || !currentPlayingChannel.urls || currentPlayingChannel.urls.length === 0) {
                console.log("No sequential playlist or end of current channel.");
                // If a non-sequential iframe channel ends, this can prevent continuous loop.
                // For live iframes, they don't typically 'end'.
                return;
            }

            currentPlaylistIndex++;
            if (currentPlaylistIndex >= currentPlayingChannel.urls.length) {
                currentPlaylistIndex = 0; // Loop back to start
                console.log("Looping playlist from beginning.");
            }

            const nextItem = currentPlayingChannel.urls[currentPlaylistIndex];
            console.log(`Playing next item in sequence: ${currentPlaylistIndex + 1}/${currentPlayingChannel.urls.length} - Type: ${nextItem.type}, URL: ${nextItem.url}`);
            
            // Hide both players and show loading while transitioning
            videoPlayer.style.display = 'none';
            iframePlayer.style.display = 'none';
            placeholder.style.display = 'none'; // Ensure placeholder is off
            unmuteButton.style.display = 'none'; // Hide mute button during transition
            showLoading(true);

            playMediaItem(nextItem);
        }

        // Function to handle playing any single media item (HLS, MP4, YouTube, etc.)
        function playMediaItem(mediaItem) {
            // Clean up previous player state
            if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
            }
            // For YouTube player, destroy it if it exists.
            // The iframe's src will be managed by the new YT.Player instance.
            if (youtubePlayer) {
                youtubePlayer.destroy(); 
                youtubePlayer = null;
            } else if (mediaItem.type !== 'youtube' && mediaItem.type !== 'iframe') { // Only clear iframe src if the NEXT item is NOT YouTube or a generic iframe
                iframePlayer.src = ''; 
            }
            
            videoPlayer.removeAttribute('src');
            videoPlayer.load(); // Reload to clear previous state
            
            // Explicitly hide both players and show loading before starting specific player setup
            videoPlayer.style.display = 'none';
            iframePlayer.style.display = 'none';
            placeholder.style.display = 'none';
            unmuteButton.style.display = 'none';
            showLoading(true);


            if (mediaItem.type === 'hls') {
                videoPlayer.style.display = 'block';
                if (Hls.isSupported()) {
                    hlsInstance = new Hls();
                    hlsInstance.loadSource(mediaItem.url);
                    hlsInstance.attachMedia(videoPlayer);
                    hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
                        videoPlayer.muted = true; // Always start muted
                        videoPlayer.autoplay = true;
                        videoPlayer.play().then(() => {
                            showLoading(false);
                            updateSpeakerIcon();
                        }).catch(e => {
                            console.error("Video playback failed (HLS, likely autoplay blocked):", e);
                            showLoading(false);
                            placeholder.style.display = 'block';
                            unmuteButton.style.display = 'none'; // Ensure button hidden if no play is possible
                            // Don't play next on autoplay failure, user needs to interact
                        });
                    });
                    hlsInstance.on(Hls.Events.ERROR, function (event, data) {
                        console.error('HLS.js error:', data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('Fatal network error encountered, trying to recover');
                                    //hlsInstance.startLoad(); // Re-enable if you want aggressive recovery
                                    playNextInSequence(); // Try next on network error
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('Fatal media error encountered, trying to recover');
                                    hlsInstance.recoverMediaError();
                                    break;
                                default:
                                    hlsInstance.destroy();
                                    showLoading(false);
                                    placeholder.style.display = 'block';
                                    unmuteButton.style.display = 'none';
                                    playNextInSequence(); // Try next on other fatal errors
                                    break;
                            }
                        }
                    });
                } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    // Native HLS support (Safari) - For sequential, this just plays the current HLS item
                    videoPlayer.src = mediaItem.url;
                    videoPlayer.muted = true;
                    videoPlayer.autoplay = true;
                    videoPlayer.play().then(() => {
                        showLoading(false);
                        updateSpeakerIcon();
                    }).catch(e => {
                        console.error("Video playback failed (Native HLS, likely autoplay blocked):", e);
                        showLoading(false);
                        placeholder.style.display = 'block';
                        unmuteButton.style.display = 'none';
                        // Don't play next on autoplay failure, user needs to interact
                    });
                    // The 'ended' listener is already globally defined at the top.
                } else {
                    console.error("HLS not supported by browser.");
                    showLoading(false);
                    placeholder.style.display = 'block';
                    unmuteButton.style.display = 'none';
                    playNextInSequence(); // Try next if HLS not supported at all
                }
            } else if (mediaItem.type === 'mp4') {
                videoPlayer.style.display = 'block';
                videoPlayer.src = mediaItem.url;
                videoPlayer.muted = true; // Always start muted
                videoPlayer.autoplay = true;
                videoPlayer.play().then(() => {
                    showLoading(false);
                    updateSpeakerIcon();
                }).catch((error) => {
                    console.error("Video playback failed (direct MP4, likely autoplay blocked):", error);
                    showLoading(false);
                    placeholder.style.display = 'block';
                    unmuteButton.style.display = 'none';
                    // Don't play next on autoplay failure, user needs to interact
                });
                // The 'ended' listener is already globally defined at the top.
            } else if (mediaItem.type === 'youtube') {
                // Extract YouTube Video ID from the embed URL
                const videoIdMatch = mediaItem.url.match(/(?:youtube\.com\/(?:embed\/|v\/|watch\?v=)|youtu\.be\/|\/)([a-zA-Z0-9_-]{11})(?:\S+)?$/);
                if (videoIdMatch && videoIdMatch[1]) {
                    const videoId = videoIdMatch[1];
                    console.log("Loading YouTube video ID:", videoId);
                    createYouTubePlayer(videoId, true); // Create and initially mute
                } else {
                    console.error("Invalid YouTube URL format:", mediaItem.url);
                    showLoading(false);
                    placeholder.style.display = 'block';
                    unmuteButton.style.display = 'none';
                    playNextInSequence(); // Try next on invalid URL
                }
            } else if (mediaItem.type === 'iframe') { // For generic iframes, not YouTube API controlled
                iframePlayer.style.display = 'block';
                iframePlayer.src = mediaItem.url;
                unmuteButton.style.display = 'none'; // Unmute button not applicable for generic iframes

                iframePlayer.onload = () => {
                    showLoading(false);
                    // No 'ended' event for generic iframes unless the content inside it controls it.
                    // For live streams, it's continuous.
                    // If it's not a live stream and needs to advance, you'll need custom logic (e.g., a timer).
                };
                iframePlayer.onerror = () => {
                    console.error("Iframe failed to load.");
                    showLoading(false);
                    placeholder.style.display = 'block';
                    playNextInSequence(); // Try next on failure
                };
            } else {
                console.error("Unknown media type:", mediaItem.type, "for URL:", mediaItem.url);
                showLoading(false);
                placeholder.style.display = 'block';
                unmuteButton.style.display = 'none';
                playNextInSequence(); // Try next on unknown type
            }
        }


        // This is the main function called when a channel is selected from the dropdown
        function playChannel(channel) {
            console.log(`Selected channel: ${channel.name}, Type: ${channel.type}`);

            currentPlayingChannel = channel; // Store the entire channel object
            currentPlaylistIndex = 0; // Reset index for new channel

            // If the channel is a "mixed" sequential playlist
            if (channel.type === 'mixed' && channel.urls && channel.urls.length > 0) {
                playMediaItem(channel.urls[currentPlaylistIndex]);
            }
            // If it's a single HLS stream (from previous setup)
            else if (channel.type === 'hls' && channel.url) {
                playMediaItem({ type: 'hls', url: channel.url });
            }
            // If it's a single iframe stream (from previous setup)
            else if (channel.type === 'iframe' && channel.url) {
                playMediaItem({ type: 'iframe', url: channel.url });
            }
            else {
                console.error("Channel definition invalid or unsupported:", channel);
                showLoading(false);
                placeholder.style.display = 'block';
                unmuteButton.style.display = 'none';
            }
        }


        function updateChannelDropdown(data) {
            const currentSelectedValue = select.value;
            select.innerHTML = '<option value="">ðŸ‘‰ðŸ“ºðŸ“ºðŸ“º</option>';

            data.forEach((channel, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = channel.name;
                select.appendChild(option);
            });
            console.log('Channel dropdown updated.');

            if (currentSelectedValue !== "") {
                const reselectIndex = parseInt(currentSelectedValue, 10);
                if (!isNaN(reselectIndex) && reselectIndex < data.length) {
                    select.value = reselectIndex;
                } else {
                    select.value = "";
                }
            }
        }

        async function fetchAndPopulateChannels() {
            try {
                const urlWithCacheBuster = `${githubJsonUrl}?cacheBuster=${new Date().getTime()}`;
                const response = await fetch(urlWithCacheBuster);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                console.log('Fetching channels.json data.');
                channelsData = data;
                updateChannelDropdown(channelsData);

                // Auto-play the first channel upon load if desired (optional)
                if (channelsData.length > 0 && select.value === "") { // Only if nothing is pre-selected
                    select.value = 0; // Select the first channel
                    playChannel(channelsData[0]);
                }

            } catch (error) {
                console.error('Failed to fetch or process channels data:', error);
                showLoading(false);
                placeholder.style.display = 'block';
            }
        }

        select.addEventListener('change', () => {
            const selectedIndex = select.value;
            if (selectedIndex === "") {
                // Clear all players and states when placeholder is selected
                if (hlsInstance) { hlsInstance.destroy(); hlsInstance = null; }
                if (youtubePlayer) { youtubePlayer.destroy(); youtubePlayer = null; } // Destroy YouTube player
                videoPlayer.removeAttribute('src');
                videoPlayer.load();
                iframePlayer.src = ''; // Clear iframe src for placeholder selection
                
                videoPlayer.style.display = 'none';
                iframePlayer.style.display = 'none';
                placeholder.style.display = 'block'; // Show placeholder
                unmuteButton.style.display = 'none';
                showLoading(false);
                
                currentPlayingChannel = null;
                currentPlaylistIndex = 0;
                return;
            }
            const selectedChannel = channelsData[selectedIndex];
            if (selectedChannel) {
                playChannel(selectedChannel);
            }
        });

        // --- Viewer Count Animation ---
        function getRandomViewerCount(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function animateViewerCount(start, end, duration) {
            let startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                const animatedValue = Math.floor(start + (end - start) * progress);
                viewerCountElement.textContent = `LIVE: ${animatedValue.toLocaleString()} VIEWERS`;

                if (progress < 1) {
                    requestAnimationFrame(step);
                }
            }
            requestAnimationFrame(step);
        }

        function updateViewerCount() {
            const newViewerCount = getRandomViewerCount(minViewers, maxViewers);
            animateViewerCount(currentViewerCount, newViewerCount, animationDuration);
            currentViewerCount = newViewerCount;
        }

        // Initial fetch and start viewer count updates
        fetchAndPopulateChannels();
        updateViewerCount(); // Initial display
        setInterval(updateViewerCount, updateInterval);
        setInterval(fetchAndPopulateChannels, pollingInterval); // Keep polling for new channels in JSON
    </script>
</body>
</html>
