<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TV Broadcast</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: sans-serif;
            color: white;
        }
        .video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Ensures the video fits within the container */
            display: block;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s ease-in-out;
            pointer-events: all; /* Make sure it's clickable (for errors/messages) */
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Disable interaction when hidden */
        }
        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid gold; /* Golden yellow spinner */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            margin-top: 20px;
            font-size: 1.2em;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .mute-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 11; /* Above the video, below loading overlay */
            transition: background 0.3s ease;
        }
        .mute-button:hover {
            background: rgba(0, 0, 0, 0.7);
        }
        .mute-button img {
            width: 30px;
            height: 30px;
            filter: invert(100%); /* Make icon white */
        }
    </style>
</head>
<body>
    <div class="video-container">
        <video id="videoPlayer" playsinline autoplay muted></video>

        <button id="muteToggle" class="mute-button">
            <img id="muteIcon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNCA5aDRsNi02djE4bC02LTYuMDAxSDRsMFY5em0xNC0xYzAgLjQ0OS0uMDU1Ljg3My0uMTYxIDEuMjY4bDMuMDA4IDMuMDA4Yy42ODMtLjc0OCAxLjE1Mi0xLjc0MSAxLjE1Mi0yLjU5NlY4YzAtMy41MzItMi42NDQtNi40MDMtNi03LjQxNnYyLjAzMWMzLjIxOCAxLjAyMiA1LjQ2IDMuODc1IDUuNDYgNi4zODV6bS0yLjgzMiA0LjI2OGwtMS45MjUtMS45MjVjLS42MjguNjI3LTEuMDQ3IDEuNDctMS4wNDcgMi4zODN2Mi40MjNjMC0xLjU4Ni41NTktMy4wNTEgMS43NzItNC41OTZ6TTUuNDEyIDcuMDc4TDggOS42NjlWN0w1LjQxMiA3LjA3OHoiLz48L3N2Z24+" alt="Mute Icon">
        </button>

        <div id="loadingOverlay" class="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-text">Loading broadcast...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const videoPlayer = document.getElementById('videoPlayer');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const muteToggle = document.getElementById('muteToggle');
        const muteIcon = document.getElementById('muteIcon');
        let hls;
        let isMuted = true; // Initial state: video starts muted
        let currentSegmentIndex = 0;
        let segmentPlayTimeout;

        // Function to get query parameters
        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        // Fetch video data
        async function fetchVideoData() {
            try {
                const response = await fetch('/videos.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Could not fetch video data:", error);
                return null;
            }
        }

        function parseDateTimeInTimeZone(dateTimeString, timeZone) {
            try {
                const dateStringWithOffset = `${dateTimeString}+10:00`;
                const dateInAEST = new Date(dateStringWithOffset);
                if (isNaN(dateInAEST.getTime())) {
                    throw new Error("Invalid date string or timezone parsing.");
                }
                return dateInAEST.getTime();
            } catch (e) {
                console.error(`Error parsing date-time string "${dateTimeString}" in timezone "${timeZone}":`, e);
                return null;
            }
        }

        function getCurrentSegmentAndSeekTime(broadcastStartTimeMs, segments) {
            const currentTimeMs = Date.now();
            const totalElapsedTimeSeconds = (currentTimeMs - broadcastStartTimeMs) / 1000;

            if (segments.length === 0) {
                return null;
            }

            let accumulatedDuration = 0;
            let currentSegment = null;
            let currentSegmentIdx = -1;
            let seekTimeInSegment = 0;

            const totalSegmentsDuration = segments.reduce((sum, s) => sum + s.durationSeconds, 0);

            const effectiveTimeInCycle = totalSegmentsDuration > 0 ?
                totalElapsedTimeSeconds % totalSegmentsDuration :
                0;

            const normalizedEffectiveTime = effectiveTimeInCycle < 0 ?
                                           effectiveTimeInCycle + totalSegmentsDuration :
                                           effectiveTimeInCycle;

            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (normalizedEffectiveTime >= accumulatedDuration &&
                    normalizedEffectiveTime < accumulatedDuration + segment.durationSeconds) {

                    currentSegment = segment;
                    currentSegmentIdx = i;
                    seekTimeInSegment = normalizedEffectiveTime - accumulatedDuration;
                    break;
                }
                accumulatedDuration += segment.durationSeconds;
            }

            if (!currentSegment && segments.length > 0) {
                currentSegment = segments[0];
                currentSegmentIdx = 0;
                seekTimeInSegment = 0;
            }

            return {
                segment: currentSegment,
                seekTime: seekTimeInSegment,
                segmentIndex: currentSegmentIdx
            };
        }

        // Renamed and streamlined this function
        function playSegment(url, seekTime, segmentDuration, currentSegmentIdx, allSegments) {
            if (hls) {
                hls.destroy(); // Destroy previous HLS instance
            }
            clearTimeout(segmentPlayTimeout); // Clear any existing timeout

            // Always show loading spinner first
            loadingOverlay.classList.remove('hidden');

            // Explicitly ensure video is muted *before* attempting play
            videoPlayer.muted = true;
            isMuted = true; // Sync our internal state
            updateMuteIcon(); // Update the icon to reflect muted state

            console.log(`Preparing segment ${currentSegmentIdx + 1}: ${url}`);

            const setupPlaybackAndPlay = () => {
                // This flag prevents this function from running multiple times for a single load
                if (videoPlayer.dataset.playbackSetupDone) return;
                videoPlayer.dataset.playbackSetupDone = 'true';

                if (isNaN(videoPlayer.duration) || videoPlayer.duration <= 0) {
                    console.warn(`Video duration not yet available or invalid for ${url}.`);
                }

                videoPlayer.currentTime = seekTime;
                console.log(`Attempting to play segment ${currentSegmentIdx + 1} at ${seekTime.toFixed(2)}s. Declared video duration: ${videoPlayer.duration.toFixed(2)}s`);

                videoPlayer.play().then(() => {
                    loadingOverlay.classList.add('hidden'); // Hide loading spinner on successful play
                    console.log(`Video playing successfully (muted).`);

                    // Set up timeout for next segment
                    const remainingPlayTime = segmentDuration - videoPlayer.currentTime;
                    if (remainingPlayTime > 0) {
                         segmentPlayTimeout = setTimeout(() => {
                             console.log("Segment duration reached, moving to next segment.");
                             playNextSegment(currentSegmentIdx, allSegments);
                         }, remainingPlayTime * 1000);
                         console.log(`Scheduled next segment in ${remainingPlayTime.toFixed(2)} seconds.`);
                    } else {
                        console.warn("Segment's effective play time is zero or negative, moving to next segment immediately.");
                        playNextSegment(currentSegmentIdx, allSegments);
                    }

                }).catch(error => {
                    console.error("Video play failed even when muted (very rare, user interaction might be forced):", error);
                    loadingOverlay.innerHTML = `<div class='loading-text'>Autoplay blocked. Please refresh. Error: ${error.message}</div>`;
                });
            };

            if (Hls.isSupported()) {
                hls = new Hls();
                hls.loadSource(url);
                hls.attachMedia(videoPlayer);

                hls.on(Hls.Events.MANIFEST_PARSED, setupPlaybackAndPlay);
                hls.on(Hls.Events.ERROR, function(event, data) {
                    console.error("HLS.js error:", data);
                    if (data.fatal) {
                        switch(data.type) {
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error("Fatal MEDIA_ERROR encountered, trying to recover.");
                                hls.recoverMediaError();
                                break;
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error("Fatal NETWORK_ERROR encountered, might need user refresh.");
                                break;
                            default:
                                console.error("Unrecoverable HLS error. Stopping playback.");
                                if (hls) hls.destroy();
                                loadingOverlay.innerHTML = "<div class='loading-text'>Video playback error. Please try again.</div>";
                                break;
                        }
                    }
                    loadingOverlay.classList.add('hidden'); // Hide spinner on error
                });
                videoPlayer.onloadedmetadata = () => {
                    if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 1) { // ENOUGH_DATA
                         console.log("Video metadata loaded (non-HLS or early event).");
                         setupPlaybackAndPlay();
                    }
                };
                videoPlayer.oncanplay = () => {
                    if (!videoPlayer.dataset.playbackSetupDone && videoPlayer.readyState >= 3) { // ENOUGH_DATA for smooth play
                        console.log("Video can play (oncanplay event).");
                        setupPlaybackAndPlay();
                    }
                };


            } else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                // For native HLS support (Safari)
                videoPlayer.src = url;
                videoPlayer.addEventListener('loadedmetadata', function listener() {
                    this.removeEventListener('loadedmetadata', listener);
                    setupPlaybackAndPlay();
                });
                videoPlayer.onerror = () => {
                    console.error("Native HLS video error.");
                    loadingOverlay.classList.add('hidden');
                };
            } else {
                console.error("HLS is not supported in this browser.");
                loadingOverlay.classList.add('hidden');
                alert("Your browser does not support HLS video streaming.");
            }
        }

        function playNextSegment(currentIdx, segments) {
            if (!window.selectedChannelData) {
                console.error("No channel data available for next segment playback.");
                return;
            }

            const currentBroadcastData = getCurrentSegmentAndSeekTime(
                window.selectedChannelData.broadcastStartTimeMs,
                window.selectedChannelData.segments
            );

            if (currentBroadcastData && currentBroadcastData.segment) {
                currentSegmentIndex = currentBroadcastData.segmentIndex;
                playSegment(
                    currentBroadcastData.segment.url,
                    currentBroadcastData.seekTime,
                    currentBroadcastData.segment.durationSeconds,
                    currentBroadcastData.segmentIndex,
                    window.selectedChannelData.segments
                );
            } else {
                 console.error("Could not determine next segment to play after timeout.");
                 // Fallback: try to play the first segment from start if something went wrong
                 currentSegmentIndex = 0;
                 playSegment(
                    segments[0].url,
                    0,
                    segments[0].durationSeconds,
                    0,
                    window.selectedChannelData.segments
                 );
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            videoPlayer.muted = isMuted;
            updateMuteIcon();
            // If the video is currently paused (e.g. by autoplay policy),
            // attempting to unmute might give it the user gesture needed to play.
            if (!videoPlayer.paused && !videoPlayer.playing) { // Check if it's not currently playing/paused by user
                 videoPlayer.play().catch(e => console.log("Attempted play after mute toggle, but failed:", e));
            }
        }

        function updateMuteIcon() {
            if (isMuted) {
                muteIcon.src = "data:image/svg+xml;base64,PHN2dmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTRIDls0bDYtNnYxOGwLNi02LjAwMUg0bDBWOXptMTQtMWMwIC40NDktLjA1NS44NzMtLjE2MSAxLjI2OGwzLjAwOCAzLjAwOGMuNjgzLS43NDggMS4xNTItMS43NDEgMS4xNTItMi41OTZWOGMwLTMuNTMyLTIuNjQ0LTYuNDAzLTYtNy40MTZ2Mi4wMzFjMy4yMTggMS4wMjIgNS40NiAzLjg3NSA1LjQ2IDYuMzg1em0tMi44MzIgNC4yNjhsLTEuOTI1LTEuOTI1Yy0uNjI4LjYyNy0xLjA0NyAxLjQ3LTEuMDQ3IDIuMzgzdjIuNDIzYzAtMS41ODYuNTU5LTMuMDUxIDEuNzcyLTQuNTk2em01LjQxMiA3LjA3OEw4IDkuNjY5VjBMNy40MTIgNy4wNzh6Ii8+PC9zdmc+";
            } else {
                muteIcon.src = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgMkw2IDdIMlYxN0g2TDEyIDIyVjJNMTcgMTJjMC0yLjY3IDEuMzMtNSA0LTYuNTYtMS4zMy0xLjczLTMtMy4wMS00LjUtMy42MVYxMS45OXpNMjIgMTJjMC00Ljg2LTMuMjYtOC45Ny03Ljg3LTEwLjk1TDE0IDAuMTRjNS40IDIgOSAyLjA2IDkgMTAuODYtMS4zNyAyLTcuMzQgMi4xNC05IDJ6Ii8+PC9zdmc+";
            }
        }

        window.selectedChannelData = null;

        document.addEventListener('DOMContentLoaded', async () => {
            const channel = getQueryParam('ch');

            if (!channel) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Please specify a channel (e.g., ?ch=1)</div>";
                return;
            }

            const videoData = await fetchVideoData();
            if (!videoData) {
                loadingOverlay.innerHTML = "<div class='loading-text'>Error loading video data.</div>";
                return;
            }

            const selectedChannel = videoData.find(v => v.channel === parseInt(channel));

            if (selectedChannel) {
                const broadcastStartTimeMs = parseDateTimeInTimeZone(selectedChannel.startDateTimeAEST, 'Australia/Melbourne');

                if (broadcastStartTimeMs === null) {
                    loadingOverlay.innerHTML = "<div class='loading-text'>Error: Invalid start time for channel.</div>";
                    return;
                }

                window.selectedChannelData = {
                    broadcastStartTimeMs: broadcastStartTimeMs,
                    segments: selectedChannel.segments
                };

                const initialBroadcastState = getCurrentSegmentAndSeekTime(broadcastStartTimeMs, selectedChannel.segments);

                if (initialBroadcastState && initialBroadcastState.segment) {
                    currentSegmentIndex = initialBroadcastState.segmentIndex;
                    playSegment(
                        initialBroadcastState.segment.url,
                        initialBroadcastState.seekTime,
                        initialBroadcastState.segment.durationSeconds,
                        initialBroadcastState.segmentIndex,
                        selectedChannel.segments
                    );
                } else {
                    console.error("No segments found for this channel or initial state could not be determined.");
                    loadingOverlay.innerHTML = "<div class='loading-text'>Channel has no video segments.</div>";
                }

            } else {
                console.error(`Channel ${channel} not found.`);
                loadingOverlay.innerHTML = `<div class='loading-text'>Channel ${channel} not found.</div>`;
            }

            muteToggle.addEventListener('click', toggleMute);

            videoPlayer.controls = false;
        });
    </script>
</body>
</html>
